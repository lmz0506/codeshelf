# CodeShelf 在线更新配置指南

## 概述

CodeShelf 使用 Tauri 的 updater 插件 + GitHub Releases 实现在线更新。

**工作流程：**

```
修改代码 → 更新版本号 → 创建 release 分支并推送 → GitHub Actions 自动构建 → 生成 Release → 用户检查更新 → 下载安装
```

> **注意：** 构建只会在 `release/*` 或 `release/**` 分支上触发，不会在 main 分支触发。

---

## 一、生成签名密钥（仅需一次）

Tauri updater 要求对更新包签名，防止被篡改。

### 1. 生成密钥对

```bash
npm run tauri signer generate -- -w ~/.tauri/codeshelf.key
```

执行后会输出：

```
Please enter a password to protect the secret key:    # 输入密码（可留空直接回车）
Password:
Deriving a key from the password and target...

Your keypair was generated successfully
Private: /Users/you/.tauri/codeshelf.key
Public:  dW50cnVzdGVkIGNvbW1lbnQ6IG1pbmlzaWduIHB1Y...   ← 复制这个公钥
```

### 2. 将公钥写入配置

打开 `src-tauri/tauri.conf.json`，将公钥替换 `YOUR_PUBLIC_KEY_HERE`：

```json
"plugins": {
  "updater": {
    "pubkey": "这里粘贴上一步输出的公钥字符串",
    "endpoints": [
      "https://github.com/en-o/codeshelf/releases/latest/download/latest.json"
    ]
  }
}
```

### 3. 保存私钥

妥善保管 `~/.tauri/codeshelf.key` 文件，后续配置 GitHub Secrets 需要用到。

---

## 二、配置 GitHub Secrets

进入 GitHub 仓库页面：**Settings → Secrets and variables → Actions → New repository secret**

添加以下两个 Secret：

| Secret 名称 | 值 |
|---|---|
| `TAURI_SIGNING_PRIVATE_KEY` | `~/.tauri/codeshelf.key` 文件的全部内容 |
| `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` | 生成密钥时输入的密码（如果留空则填空字符串） |

> **提示：** 步骤一和步骤二（生成密钥 + 配置 GitHub Secrets）只需要 **配置一次**。后续发布新版本只需要执行下面的步骤三即可。

---

## 三、发布新版本

### 方式一：使用快速发版脚本（推荐）

项目提供了快速发版脚本，一键完成版本号更新、提交、创建分支、推送等操作。

**Linux / macOS / WSL：**

```bash
./scripts/release.sh 0.2.0
```

**Windows (CMD / PowerShell)：**

```cmd
scripts\release.bat 0.2.0
```

脚本会自动执行以下操作：
1. 更新三个文件的版本号
2. 提交更改 (`chore: release v0.2.0`)
3. 创建 `release/0.2.0` 分支
4. 推送到远程触发 GitHub Actions 构建
5. 自动切回 main 分支

---

### 方式二：手动发版

#### 1. 修改版本号

发布前需要同步修改 **三个文件** 的版本号：

| 文件 | 字段 | 示例 |
|---|---|---|
| `src-tauri/tauri.conf.json` | `"version"` | `"0.2.0"` |
| `package.json` | `"version"` | `"0.2.0"` |
| `src-tauri/Cargo.toml` | `version` | `"0.2.0"` |

> **注意：** 三个文件的版本号必须保持一致。

#### 2. 创建 release 分支并推送

```bash
# 在 main 分支上更新版本号
git add -A
git commit -m "chore: bump version to 0.2.0"

# 创建 release 分支（分支名格式：release/版本号）
git checkout -b release/0.2.0

# 推送 release 分支，触发 GitHub Actions 构建
git push origin release/0.2.0
```

---

### 3. 等待 GitHub Actions 构建

推送 release 分支后，GitHub Actions 会自动：

1. 在 Windows、macOS（x86 + ARM）、Linux 三个平台并行构建
2. 生成安装包和签名文件
3. 创建 **Draft Release**（草稿状态）
4. 上传所有构建产物，包含关键的 `latest.json`

### 4. 发布 Release

1. 进入 GitHub 仓库 → **Releases** 页面
2. 找到刚创建的 Draft Release
3. 编辑更新日志（Release Notes）
4. 点击 **Publish release**

### 5. 合并回 main 分支（可选）

发布完成后，将 release 分支合并回 main：

```bash
git checkout main
git merge release/0.2.0
git push origin main

# 可选：删除 release 分支
git branch -d release/0.2.0
git push origin --delete release/0.2.0
```

发布后，`latest.json` 的访问地址为：

```
https://github.com/en-o/codeshelf/releases/latest/download/latest.json
```

---

## 四、用户端更新

用户打开 CodeShelf → **设置 → 应用更新 → 检查更新**

如果有新版本，界面会显示版本号和更新日志，点击「下载并安装更新」即可自动完成：

1. 下载更新包（显示进度条）
2. 验证签名
3. 安装更新
4. 自动重启应用

---

## 五、文件结构说明

```
codeshelf/
├── .github/workflows/
│   └── release.yml                # GitHub Actions 构建发布工作流
├── scripts/
│   ├── release.sh                 # 快速发版脚本 (Linux/macOS/WSL)
│   └── release.bat                # 快速发版脚本 (Windows)
├── src-tauri/
│   ├── tauri.conf.json            # updater 配置（pubkey、endpoints）
│   ├── Cargo.toml                 # tauri-plugin-updater 依赖
│   └── src/lib.rs                 # 注册 updater 插件
├── src/
│   ├── services/updater/index.ts  # 更新检查与下载逻辑
│   └── pages/Settings/
│       └── UpdateSettings.tsx     # 更新设置界面
└── package.json                   # @tauri-apps/plugin-updater 依赖
```

---

## 六、分支策略

```
main (主分支，日常开发)
  │
  ├── release/0.1.0  →  触发构建  →  发布 v0.1.0
  │
  ├── release/0.2.0  →  触发构建  →  发布 v0.2.0
  │
  └── release/1.0.0  →  触发构建  →  发布 v1.0.0
```

- **main 分支**：日常开发，推送不会触发构建
- **release/* 分支**：版本发布分支，推送会自动触发 GitHub Actions 构建

---

## 七、常见问题

### Q: 构建失败提示缺少 TAURI_SIGNING_PRIVATE_KEY？

确认已在 GitHub 仓库的 **Settings → Secrets → Actions** 中正确添加了 `TAURI_SIGNING_PRIVATE_KEY` 和 `TAURI_SIGNING_PRIVATE_KEY_PASSWORD`。

### Q: 用户检查更新提示网络错误？

- 确认 Release 已从 Draft 状态改为 Published
- 确认 Release 的 Assets 中包含 `latest.json` 文件
- 国内网络可能无法直接访问 GitHub，可考虑使用代理或更换 endpoint 为镜像地址

### Q: 更新后版本没变？

三个文件的版本号必须一致且大于当前版本。检查：
- `src-tauri/tauri.conf.json` → `version`
- `package.json` → `version`
- `src-tauri/Cargo.toml` → `version`

### Q: 只想构建 Windows 版本？

修改 `.github/workflows/release.yml`，删除 `matrix` 中不需要的平台配置，只保留：

```yaml
matrix:
  include:
    - platform: 'windows-latest'
      args: ''
```

### Q: 如何手动触发构建？

工作流已配置 `workflow_dispatch`，可在 GitHub 仓库 → **Actions → Release → Run workflow** 手动触发，并输入版本号。

### Q: 推送到 main 分支会触发构建吗？

**不会**。构建只在 `release/*` 或 `release/**` 分支上触发。

### Q: GitHub Actions 配置需要每次都做吗？

**不需要**。整个配置过程分为：

| 步骤 | 频率 | 说明 |
|---|---|---|
| 一、生成签名密钥 | 一次性 | 只需生成一次密钥对，长期使用 |
| 二、配置 GitHub Secrets | 一次性 | 将私钥配置到 GitHub，只需一次 |
| 三、发布新版本 | 每次发布 | 只需修改版本号 + 推送 release 分支 |

首次配置完成后，后续发布新版本的流程非常简单：

```bash
# 使用脚本一键发版（推荐）
./scripts/release.sh 0.2.0      # Linux/macOS/WSL
scripts\release.bat 0.2.0       # Windows
```

---

## 附录：快速发版脚本源码

### release.sh (Linux/macOS/WSL)

```bash
#!/bin/bash

# CodeShelf 快速发版脚本
# 用法: ./scripts/release.sh 0.2.0

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

info() { echo -e "${BLUE}[INFO]${NC} $1"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; exit 1; }

if [ -z "$1" ]; then
    echo "用法: $0 <版本号>"
    echo "示例: $0 0.2.0"
    exit 1
fi

VERSION=$1

if ! [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    error "版本号格式无效: $VERSION (应为 x.y.z)"
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
cd "$PROJECT_ROOT"

BRANCH_NAME="release/$VERSION"

# 检查分支是否已存在
git show-ref --verify --quiet "refs/heads/$BRANCH_NAME" && \
    error "本地分支 $BRANCH_NAME 已存在"
git ls-remote --exit-code --heads origin "$BRANCH_NAME" &>/dev/null && \
    error "远程分支 origin/$BRANCH_NAME 已存在"

info "更新版本号..."

# 更新 package.json
node -e "
    const fs = require('fs');
    const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
    pkg.version = '$VERSION';
    fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
"

# 更新 src-tauri/tauri.conf.json
node -e "
    const fs = require('fs');
    const conf = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
    conf.version = '$VERSION';
    fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(conf, null, 2) + '\n');
"

# 更新 src-tauri/Cargo.toml
if [[ "$OSTYPE" == "darwin"* ]]; then
    sed -i '' "s/^version = \"[0-9]*\.[0-9]*\.[0-9]*\"/version = \"$VERSION\"/" src-tauri/Cargo.toml
else
    sed -i "s/^version = \"[0-9]*\.[0-9]*\.[0-9]*\"/version = \"$VERSION\"/" src-tauri/Cargo.toml
fi

success "版本号更新完成"

# Git 操作
git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml
git commit -m "chore: release v$VERSION"
git checkout -b "$BRANCH_NAME"
git push origin "$BRANCH_NAME"
git checkout main

success "发版流程启动成功！版本: v$VERSION"
echo "请前往 GitHub Actions 查看构建进度"
```

### release.bat (Windows)

```batch
@echo off
chcp 65001 >nul 2>&1
setlocal EnableDelayedExpansion

:: CodeShelf 快速发版脚本 (Windows)
:: 用法: release.bat 0.2.0

if "%~1"=="" (
    echo 用法: %~nx0 ^<版本号^>
    echo 示例: %~nx0 0.2.0
    exit /b 1
)

set VERSION=%~1

cd /d "%~dp0.."
set PROJECT_ROOT=%cd%

echo [INFO] 项目目录: %PROJECT_ROOT%
echo [INFO] 目标版本: %VERSION%

set BRANCH_NAME=release/%VERSION%

:: 检查分支是否存在
git show-ref --verify --quiet "refs/heads/%BRANCH_NAME%" 2>nul
if not errorlevel 1 (
    echo [ERROR] 本地分支 %BRANCH_NAME% 已存在
    exit /b 1
)

echo [INFO] 更新版本号...

:: 更新 package.json
node -e "const fs=require('fs');const p=JSON.parse(fs.readFileSync('package.json','utf8'));p.version='%VERSION%';fs.writeFileSync('package.json',JSON.stringify(p,null,2)+'\n');"
echo [SUCCESS] package.json -^> %VERSION%

:: 更新 src-tauri/tauri.conf.json
node -e "const fs=require('fs');const c=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json','utf8'));c.version='%VERSION%';fs.writeFileSync('src-tauri/tauri.conf.json',JSON.stringify(c,null,2)+'\n');"
echo [SUCCESS] src-tauri/tauri.conf.json -^> %VERSION%

:: 更新 src-tauri/Cargo.toml
node -e "const fs=require('fs');let c=fs.readFileSync('src-tauri/Cargo.toml','utf8');c=c.replace(/^version = \"[0-9]+\.[0-9]+\.[0-9]+\"/m,'version = \"%VERSION%\"');fs.writeFileSync('src-tauri/Cargo.toml',c);"
echo [SUCCESS] src-tauri/Cargo.toml -^> %VERSION%

:: Git 操作
git add package.json src-tauri/tauri.conf.json src-tauri/Cargo.toml
git commit -m "chore: release v%VERSION%"
git checkout -b "%BRANCH_NAME%"
git push origin "%BRANCH_NAME%"
git checkout main

echo.
echo [SUCCESS] 发版流程启动成功！
echo 版本号: v%VERSION%
echo 分支:   %BRANCH_NAME%
echo.
echo 请前往 GitHub Actions 查看构建进度:
echo https://github.com/en-o/codeshelf/actions

endlocal
```


